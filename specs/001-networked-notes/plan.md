# Implementation Plan: Networked Notes with Entity References

**Branch**: `001-networked-notes` | **Date**: 2025-12-30 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/001-networked-notes/spec.md`

**Note**: This document is generated by the `/speckit.plan` command.

## Summary

Implement a networked note-taking system where users can capture short notes via CLI (`wet add`) and reference named entities using bracket notation `[entity-name]`. The system enables querying notes by entity (`wet notes --on entity`) and listing all unique entities (`wet entities`). This builds on existing Wetware infrastructure while adding entity parsing, tracking, and query capabilities. The feature supports case-insensitive entity matching with first-occurrence capitalization preservation.

## Technical Context

**Language/Version**: Rust 2024 edition (aligns with existing codebase)
**Primary Dependencies**: clap (CLI), rusqlite (persistence), regex (entity parsing)
**Storage**: SQLite (existing wetware.db, add notes and entities tables)
**Testing**: cargo nextest, cargo tarpaulin (coverage)
**Target Platform**: Linux/macOS/Windows CLI
**Project Type**: Single CLI project (existing structure)
**Performance Goals**: <100ms for add/list operations, <500ms for entity queries
**Constraints**: Single-user local storage, 10,000 char note limit, offline-capable
**Scale/Scope**: Designed for thousands of notes, hundreds of entities

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

Verify compliance with Wetware Constitution (`.specify/memory/constitution.md`):

**I. Test-First Development (90%+ Coverage)**
- [x] Test strategy defined (unit, integration, contract)
  - Unit: Note/Entity models, entity parser
  - Integration: Storage layer interactions
  - Contract: CLI command tests
- [x] 90%+ coverage target achievable for this feature
- [x] TDD approach planned for new functionality

**II. Layer Separation**
- [x] Changes respect CLI / Domain / Persistence / Input layer boundaries
  - CLI: New subcommands (`add`, `notes`, `entities`)
  - Domain: Note, Entity, EntityReference models
  - Persistence: NotesRepository, EntitiesRepository
  - Input: Entity parser (bracket notation)
- [x] No direct dependencies from Domain to CLI or Persistence implementation
- [x] Persistence abstraction maintained (interface-based)

**III. Strong Typing & Error Handling**
- [x] Error types identified for new functionality
  - ParseError (invalid entity syntax)
  - StorageError (persistence failures)
  - ValidationError (empty notes, oversized content)
- [x] Result/Option types used (no panics in business logic)
- [x] Error context propagation planned

**IV. Observability & Documentation**
- [x] Public API documentation plan (rustdoc)
  - All public models, services, and CLI commands
- [x] Logging strategy for significant operations
  - Note creation, entity extraction, queries
- [x] Architecture decision rationale documented (this plan + research.md)

**V. Simplicity & YAGNI**
- [x] Solution is simplest that meets current requirements
  - Simple regex parser for `[entity]` syntax
  - Direct SQLite queries (no ORM complexity)
  - Minimal abstractions
- [x] No premature optimization or abstraction
- [x] No complexity violations

## Project Structure

### Documentation (this feature)

```text
specs/001-networked-notes/
├── plan.md              # This file
├── research.md          # Phase 0: Entity parsing, storage design
├── data-model.md        # Phase 1: Note, Entity, EntityReference schema
├── quickstart.md        # Phase 1: User guide for new commands
├── contracts/           # Phase 1: CLI command interface contracts
│   └── cli-commands.md
└── checklists/
    └── requirements.md  # Specification quality checklist
```

### Source Code (repository root)

```text
src/
├── models/
│   ├── note.rs          # Note domain model
│   ├── entity.rs        # Entity domain model
│   └── mod.rs
├── services/
│   ├── entity_parser.rs # Extract [entity] from text
│   └── mod.rs
├── storage/
│   ├── notes_repository.rs    # Note persistence
│   ├── entities_repository.rs # Entity persistence
│   └── mod.rs
├── cli/
│   ├── add.rs          # `wet add` command
│   ├── notes.rs        # `wet notes` command
│   ├── entities.rs     # `wet entities` command
│   └── mod.rs
├── input/
│   └── mod.rs          # Input validation
└── lib.rs

tests/
├── contract/
│   ├── test_add_command.rs
│   ├── test_notes_command.rs
│   └── test_entities_command.rs
├── integration/
│   ├── test_entity_references.rs
│   └── test_persistence.rs
└── unit/
    └── test_entity_parser.rs
```

**Structure Decision**: Using existing single project structure. The system extends current CLI with new commands while maintaining layer separation: CLI delegates to domain services, which use persistence repositories. Entity parsing is isolated in services layer.

## Complexity Tracking

No constitution violations - all requirements met with simple, straightforward architecture.

## Phase 0: Research & Technical Decisions

### Entity Parsing Strategy

**Decision**: Regex-based parser with pattern `\[([^\[\]]+)\]`

**Rationale**:
- Simple and efficient for single-bracket entity syntax
- Handles spaces and special chars within brackets
- Prevents nested brackets `[[entity]]` naturally
- Well-tested standard library (regex crate)

**Alternatives Considered**:
- Manual character-by-character parsing: More complex, no performance benefit
- Full parser combinator (nom): Overkill for simple bracket syntax

**Implementation Notes**:
- Extract all matches, deduplicate case-insensitively
- Preserve first occurrence capitalization
- Handle malformed syntax gracefully (unclosed brackets ignored)

### Storage Schema Design

**Decision**: Three tables: `notes`, `entities`, `note_entities` (junction)

**Rationale**:
- Normalized design prevents entity name duplication
- Junction table enables efficient many-to-many queries
- Supports case-insensitive matching with COLLATE NOCASE
- Aligns with existing SQLite usage patterns

**Schema**:
```sql
CREATE TABLE notes (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    content TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE entities (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL UNIQUE COLLATE NOCASE,
    canonical_name TEXT NOT NULL  -- First occurrence capitalization
);

CREATE TABLE note_entities (
    note_id INTEGER NOT NULL,
    entity_id INTEGER NOT NULL,
    PRIMARY KEY (note_id, entity_id),
    FOREIGN KEY (note_id) REFERENCES notes(id) ON DELETE CASCADE,
    FOREIGN KEY (entity_id) REFERENCES entities(id) ON DELETE CASCADE
);

CREATE INDEX idx_note_entities_entity ON note_entities(entity_id);
```

**Alternatives Considered**:
- Denormalized (store entities as JSON array in notes): Poor query performance
- Single entities table with note_id foreign key: Doesn't support many-to-many

### Case-Insensitive Entity Matching

**Decision**: Use `COLLATE NOCASE` on entity name + `canonical_name` column

**Rationale**:
- SQL handles case-insensitive lookups efficiently
- `canonical_name` preserves first occurrence for display
- No application-layer string manipulation needed
- Standard SQLite feature, well-tested

**Implementation**:
- INSERT OR IGNORE with COLLATE NOCASE prevents duplicates
- Return canonical_name for display
- Query by name works regardless of casing

### CLI Command Design

**Decision**: Extend existing `wet` binary with subcommands

**Commands**:
- `wet add <text>` - Add note (existing pattern)
- `wet notes` - List all notes chronologically
- `wet notes --on <entity>` - Filter by entity
- `wet entities` - List unique entities

**Rationale**:
- Consistent with existing CLI structure
- Subcommand pattern familiar to users
- clap handles argument parsing

### Error Handling Strategy

**Error Types**:
```rust
pub enum NoteError {
    InvalidInput(String),      // Empty note, too long
    ParseError(String),         // Entity syntax issues (non-fatal)
    StorageError(String),       // DB failures
}
```

**Rationale**:
- Distinct error types for different failure modes
- ParseError is non-fatal (malformed entities ignored)
- User-friendly messages for CLI display
- Preserves context for debugging

## Phase 1: Data Model & Contracts

### Data Model

See [data-model.md](./data-model.md) for complete entity definitions, field types, relationships, and state transitions.

**Key Entities**:
- **Note**: ID, content, created_at, entity_references
- **Entity**: ID, name (case-insensitive), canonical_name (display form)
- **EntityReference**: note_id, entity_id (many-to-many)

### API Contracts

See [contracts/cli-commands.md](./contracts/cli-commands.md) for complete CLI interface specification.

**CLI Commands**:
- `wet add '<text>'` → Note created confirmation
- `wet notes` → Chronological list of all notes
- `wet notes --on <entity>` → Filtered list
- `wet entities` → Unique entity list

### Quickstart Guide

See [quickstart.md](./quickstart.md) for user-facing guide to new functionality.

## Phase 2: Implementation Roadmap

*Note: Detailed tasks will be generated by `/speckit.tasks` command*

### High-Level Implementation Order

1. **Setup**: Database migration, schema creation
2. **Domain Models**: Note, Entity structs with validation
3. **Entity Parser**: Regex-based extraction service
4. **Repositories**: Notes and Entities persistence layer
5. **CLI Commands**: add, notes, entities subcommands
6. **Integration**: Wire components, error handling
7. **Testing**: Unit, integration, contract tests
8. **Documentation**: rustdoc, quickstart validation

### Testing Strategy

**Unit Tests** (inline or tests/unit/):
- Entity parser: Valid syntax, malformed input, edge cases
- Note model: Validation, length limits
- Entity model: Case normalization

**Integration Tests** (tests/integration/):
- End-to-end note creation with entity extraction
- Entity reference persistence and retrieval
- Case-insensitive entity matching
- Query operations (filter by entity)

**Contract Tests** (tests/contract/):
- `wet add` command: Success, validation errors, special chars
- `wet notes` command: Empty state, chronological order
- `wet notes --on` command: Entity filtering, non-existent entities
- `wet entities` command: Unique list, capitalization preservation

### Performance Considerations

- SQLite indexes on note_entities(entity_id) for fast lookups
- Connection pooling (existing rusqlite pattern)
- Batch entity extraction (single regex pass)
- No N+1 queries (JOIN for entity-filtered notes)

### Deployment Considerations

- Database migration script for existing wetware.db
- Backwards compatibility (existing data unaffected)
- No new external dependencies
- Single binary deployment (existing pattern)

## Risks & Mitigations

| Risk | Mitigation |
|------|------------|
| Regex performance on large notes | Limit note size (10k chars), benchmark parser |
| Entity name collisions (case variants) | COLLATE NOCASE + canonical_name pattern |
| Database migration failures | Transactional migration, backup existing DB |
| Complex entity syntax edge cases | Graceful degradation, log parse warnings |

## Next Steps

1. Run `/speckit.tasks` to generate detailed implementation tasks
2. Review and prioritize tasks by user story
3. Begin TDD implementation starting with P1 (basic note capture)
4. Validate against constitution checklist throughout development
